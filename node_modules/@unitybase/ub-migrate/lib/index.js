const fs = require('fs')
const path = require('path')
const argv = require('@unitybase/base').argv
const yaml = require('js-yaml')

const {Pipe} = require('./pipe')
const {createContext, getContext} = require('./context')
const {getModels, getTenantIDs} = require('./domain-utils')
const {EntityRepository, NonCachedEntityRepository, EntityFormat} = require('./metadata')
const {
  flatMap,
  iterateList,
  processList,
  transform,
  arrayItemsOrSelf,
  codeToName,
  addTranslations
} = require('./metadata/utility')

module.exports = {
  exec,
  migrate,
  migrateDir,
  migrateFile,
  extend: require('./extend'),

  EntityRepository,
  NonCachedEntityRepository,
  EntityFormat,
  codeToName
}

/**
 * Execute migration as from command line.
 * @param {object} cfg
 *   Parsing `options` from `@unitybase/base`
 */
function exec(cfg) {
  const session = argv.establishConnectionFromCmdLineAttributes(cfg)

  const serverConfig = argv.getServerConfiguration(true)
  const isMultitenancySupported = serverConfig.security &&
    serverConfig.security.multitenancy &&
    serverConfig.security.multitenancy.enabled

  const domainInfo = session.connection.getDomainInfo(true)

  const models = getModels(domainInfo, cfg)
  if (models.length === 0) {
    console.warn('No models to migrate, exit.')
    return
  }
  console.log('Models to migrate:', models.map(m => m.name).join(', '))

  if (!isMultitenancySupported) {
    const stats = migrate(session, domainInfo, models, cfg)
    console.log(`Migration statistics: ${stats.totalInserts} inserted, ${stats.totalUpdates} updated, ${stats.totalSkippedUpdates} is up to date`)
    return
  }

  const tenantIDs = getTenantIDs(cfg)

  for (const t of serverConfig.security.multitenancy.tenants) {
    if (tenantIDs && !tenantIDs.includes(t.TID)) {
      continue
    }

    console.log('Starting migration of tenant %d', t.TID)

    const tCfg = Object.assign({}, cfg, {
      host: 'http://' + t.URI,
      tenantBoundOnly: t.TID !== 1
    })
    const tSession = argv.establishConnectionFromCmdLineAttributes(tCfg)

    const stats = migrate(tSession, domainInfo, models, tCfg)
    console.log(`Migration statistics: ${stats.totalInserts} inserted, ${stats.totalUpdates} updated, ${stats.totalSkippedUpdates} is up to date`)
  }
}

/**
 * @param {ServerSession} session
 * @param {UBDomain} domainInfo
 * @param {Array} models
 * @param {MigrationOptions} options
 * @return {MigrationStats}
 */
function migrate(session, domainInfo, models, options) {
  const context = createContext(session, domainInfo, options)
  migrateData(new Pipe(models, context).pipe(lookupModelsDataFiles))
  return context.stats
}

/**
 * @param {ServerSession} session
 * @param {string} fileName
 * @param {MigrationOptions} [options]
 */
function migrateFile(session, fileName, options = {}) {
  const context = getContext(session, undefined, options)
  migrateData(new Pipe([fileName], context))
}

/**
 * @param {ServerSession} session
 * @param {string} dirName
 * @param {MigrationOptions} [options]
 */
function migrateDir(session, dirName, options = {}) {
  const context = getContext(session, undefined, options)
  migrateData(new Pipe(lookupDirDataFiles(dirName), context))
}

/**
 * @param {Pipe} stream
 */
function migrateData(stream) {
  stream
    .pipe(readDataFile)
    .pipe(parseDataFile)
    .pipe(transformFile)
    .pipe(stream.context.options.tenantBoundOnly && allowTenantBoundInstancesOnly)
    .pipe(translateEntityInstance)
    .pipe(printEntityInstance)
    .pipe(updateEntityInstance)
    .run()
}

/**
 * @param {IterableIterator} models
 * @return {IterableIterator<string>}
 */
function* lookupModelsDataFiles(models) {
  for (const m of models) {
    for (const df of lookupDirDataFiles(path.join(m.realPath, '_data'))) {
      yield df
    }
  }
}

/**
 * @param {string} dir
 * @return {IterableIterator<string>}
 */
function* lookupDirDataFiles(dir) {
  if (fs.existsSync(dir)) {
    for (const fileName of fs.readdirSync(dir).sort()) {
      const ext = path.extname(fileName)
      if (ext === '.yml' || ext === '.yaml') {
        yield path.join(dir, fileName)
      }
    }
  }
}

/**
 * @typedef {object} DataFileContent
 * @property {string} fileName
 * @property {string} content
 */

/**
 * @param {IterableIterator<string>} filesInfo
 * @param {MigrationContext} context
 * @return {IterableIterator<DataFileContent>}
 */
function* readDataFile(filesInfo, context) {
  for (const fileName of filesInfo) {
    if (!context.options.silent) {
      console.log(`Reading file ${fileName}...`)
    }
    yield {fileName, content: fs.readFileSync(fileName, 'utf8')}
  }
}

/**
 * @typedef {object} DataFileParsed
 * @property {string} fileName
 * @property {string} fileType
 * @property {*} parsed
 */

/**
 * @param {IterableIterator<DataFileContent>} dataFileContents
 * @return {IterableIterator<DataFileParsed>}
 */
function* parseDataFile(dataFileContents) {
  for (const {content, fileName} of dataFileContents) {
    // Set default file type as a file name without extension
    let basename = path.basename(fileName)
    let fileType = basename.substr(0, basename.length - path.extname(fileName).length)

    let loaded
    try {
      loaded = yaml.loadAll(content)
    } catch (e) {
      throw new Error(`Error loading '${fileName}' ${e}`)
    }
    for (const yamlContent of loaded) {
      for (const contentItem of arrayItemsOrSelf(yamlContent)) {
        const {$context} = contentItem
        if ($context && $context.type) {
          fileType = $context.type
        }
        yield {fileName, fileType, parsed: contentItem}
      }
    }
  }
}

/**
 * Take a list of input files, read from disk and parsed from yaml, convert it to list
 * of entity instances defined in the file.
 * @param {IterableIterator<DataFileParsed>} parsedFiles
 * @param {MigrationContext} context
 */
function* transformFile(parsedFiles, context) {
  const instances = flatMap(parsedFiles, f => {
    const source = iterateList(f.parsed)
    // TODO: !!!!!!!!!!!!!!!
    return processList(
      source,
      (key, value, ctx) => {
        const md = ctx.container.getFileType(f.fileType) || ctx.container.getFileType(ctx['type'])
        if (!md) {
          throw new Error(
            `Neither file name "${f.fileType}" not $context.type "${ctx['type']}" do not match any data format`)
        }
        const entry = [key, value]
        return transform([entry], md, ctx, f.fileName)
      },
      context
    )
  })
  for (const item of instances) {
    yield item
  }
}

/**
 * Depending on context, skip some instances
 * @param {IterableIterator<ParsedEntityInstance>} entityInstances
 * @param {MigrationContext} context
 */
function* allowTenantBoundInstancesOnly(entityInstances, context) {
  for (const inst of entityInstances) {
    const entityInfo = context.domainInfo.get(inst.entity)
    if (!entityInfo.mixins.multitenancy) {
      if (context.options.verbose) {
        console.log('Skipped, because instance is not tenant-bound')
      }
      continue
    }
    yield inst
  }
}

/**
 * @param {IterableIterator<ParsedEntityInstance>} entityInstances
 * @param {MigrationContext} context
 */
function* translateEntityInstance(entityInstances, context) {
  for (const inst of entityInstances) {
    addTranslations(inst, context)
    yield inst
  }
}

/**
 * @param {IterableIterator<ParsedEntityInstance>} entityInstances
 * @param {MigrationContext} context
 */
function* printEntityInstance(entityInstances, context) {
  for (const inst of entityInstances) {
    if (context.options.verbose) {
      console.log(inst)
    }
    yield inst
  }
}

function* updateEntityInstance(instances, context) {
  for (const inst of instances) {
    const repository = context.container.getRepository(inst.entity)
    if (!repository) {
      console.warn(`There is no repository in this tool for entity ${inst.entity}`)
      continue
    }

    repository.save(inst, context)
  }
}
