const path = require('path')
const fs = require('fs')
const {UBDomain} = require('@unitybase/cs-shared')
const {Container} = require('./metadata')
const registerPredefinedModels = require('./registration')
const {LocaleResources} = require("./locale-resources");
const {readLocales} = require('./locale-resources')
const {getDomainInfo} = require('./domain-utils')

module.exports = {
  getContext,
  createContext
}

/**
 * Global instance of context.
 * For backward compatibility.
 * @type {MigrationContext}
 */
let globalContext = undefined

/**
 * @typedef {object} LangConfig
 * @property {string} defaultLang
 * @property {string[]} supportLang
 */

/**
 * @typedef {object} MigrationOptions
 * @property {boolean} [verbose]
 * @property {boolean} [silent]
 * @property {boolean} [noGlobalContext]=false
 *   By default (and that is important for versions <1.9.0 and for extensions formats,
 *     which are not migrated to container-aware way of extending) to use the same context.
 *   This option explicitly disable that behavior for "migrateDir" method.
 * @property {boolean} [tenantBoundOnly]
 *   This is calculated property, not passed directly from CLI!
 * @property {boolean} [skipLoadLocales]
 */

/**
 * @typedef {object} MigrationContext
 * @property {SyncConnection} conn
 * @property {UBDomain} domainInfo
 * @property {MigrationLangConfig} langConfig
 * @property {MigrationOptions} options
 * @property {MigrationStats} stats
 * @property {Container} container
 * @property {string} defaultCustomerModel
 *   For mdb store, a model where to put document attributes, if not explicitly specified
 */

/**
 * @typedef {object} MigrationLangConfig
 * @property {string} defaultLang
 * @property {string[]} supportLang
 */

/**
 * @typedef {object} MigrationStats
 * @property {number} totalInserts
 * @property {number} totalUpdates
 * @property {number} totalSkippedUpdates
 */

/**
 * Get or create context
 * @param session
 * @param domainInfo
 * @param options
 * @return {MigrationContext}
 */
function getContext(session, domainInfo, options) {
  if (options.noGlobalContext) {
    return createContext(session, undefined, options)
  }

  if (!globalContext) {
    globalContext = createContext(session, undefined, options)
    if (options.verbose) {
      console.log('Created global context')
    }
  } else {
    // This is required, because "migrateDir" is called from inside _initialData scripts, and these scripts are mixed
    // and repositories initialized during initial context creation might become obsolete
    initRepositories(globalContext)
    if (options.verbose) {
      console.log('Reinitialized global context repo')
    }
  }
  globalContext.options.verbose = options.verbose
  globalContext.options.silent = options.silent
  return globalContext
}

/**
 * @param {ServerSession} session
 * @param {UBDomain} providedDomainInfo
 * @param {MigrationOptions} options
 * @return {MigrationContext}
 */
function createContext(session, providedDomainInfo, options) {
  const domainInfo = getDomainInfo(session, providedDomainInfo, options)

  const {connection, appInfo} = session

  const langConfig = {
    defaultLang: appInfo.defaultLang,
    supportLang: appInfo.supportedLanguages
  }

  const resources = options.skipLoadLocales
    ? new LocaleResources()
    : readLocales(langConfig, connection)

  const defaultCustomerModel = domainInfo.customerModels.length > 0
    ? domainInfo.customerModels[domainInfo.customerModels.length - 1]
    : domainInfo.orderedModels[domainInfo.orderedModels.length - 1].name

  /**
   * @type {MigrationContext}
   */
  const context = {
    langConfig,
    conn: connection,
    options,
    domainInfo,
    defaultCustomerModel,
    container: new Container(options),
    resources,
    stats: {
      totalInserts: 0,
      totalUpdates: 0,
      totalSkippedUpdates: 0
    }
  }

  loadPredefinedAndExtendedFormats(domainInfo, context)
  initRepositories(context)
  return context
}

/**
 * @param {UBDomain} domainInfo
 * @param {MigrationContext} context
 */
function loadPredefinedAndExtendedFormats(domainInfo, context) {
  // Load formats for ALL models, not just models selected to run migration
  const modelNames = []
  for (const m of domainInfo.orderedModels) {
    // Only not public models (note, this requires domain with extended info!)
    if (m.realPath) {
      modelNames.push(m.name.toLowerCase())
    }
  }
  registerPredefinedModels(modelNames, context)
  loadFormats(domainInfo.orderedModels, context)
}

function loadFormats(models, context) {
  for (const m of models) {
    if (m.realPath) {
      loadFormatsFromDir(path.join(m.realPath, '_data'), context)
    }
  }
}

/**
 * @param {string} dirName
 * @param {MigrationContext} context
 */
function loadFormatsFromDir(dirName, context) {
  const extend = require('./extend')

  // This is for backward compatibility
  extend.setContainer(context.container)

  if (fs.existsSync(dirName)) {
    for (const df of fs.readdirSync(dirName).sort()) {
      if (df.endsWith('.js')) {
        const fileName = path.join(dirName, df)
        if (!context.options.silent) {
          console.log('Loading script file:', fileName, '...')
        }
        const extensionModule = require(fileName)
        if (typeof extensionModule === 'function') {
          extensionModule(context.container)
        } else {
          // Backward compatibility
          console.warn('Script file:', fileName, 'should export a function, see ub-migrate CHANGELOG, version 1.9.0!!!')
        }
      }
    }
  }
}

/**
 * @param {MigrationContext} ctx
 */
function initRepositories(ctx) {
  for (const [entity, repository] of ctx.container.getAllRepositories()) {
    if (typeof repository.init === 'function') {
      repository.init(ctx.langConfig)
    }
  }
}
