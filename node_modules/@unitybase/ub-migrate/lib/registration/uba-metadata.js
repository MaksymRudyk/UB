const {snakeCase} = require('lodash')

const {EntityRepository, NonCachedEntityRepository, EntityFormat} = require('../metadata')
const {stringToArray, iterateChildren, iterateList, transform, getAdmEntityName} = require('../metadata/utility')

function buildElsCode(val, ctx) {
  if (val.accType) {
    return `${val.acc.replace('.', '_')}_${val.accType}_${ctx.roleCode}`.toUpperCase()
  } else {
    const strEntityMask = snakeCase(val.entityMask.replace('*', '').replace(/^_+|_+$/g, ''))
    const strMethodMask = snakeCase(
      (val.methodMask === '*' ? 'all' : val.methodMask)
        .replace('*', '')
        .replace(/^_+|_+$/g, '')
    )
    return `${strEntityMask}_${strMethodMask}_${ctx.roleCode}`.toUpperCase()
  }
}

function buildElsDescription(val, ctx) {
  if (val.accType) {
    return `${ctx.roleCode} ${val.accType} access to ${val.acc} ${val.scope}`
  } else {
    const strEntity = val.entityMask.indexOf('*') !== -1 ? 'entities' : 'entity'
    const strMethod = val.methodMask.indexOf('*') !== -1 ? 'methods' : 'method'
    const strMethodMask = val.methodMask === '*' ? 'all' : val.methodMask
    return `${ctx.roleCode} access to ${val.entityMask} ${strEntity}, ${strMethodMask} ${strMethod}`
  }
}

function indexByID(instances) {
  const byID = new Map()
  for (const i of instances) {
    byID.set(i.ID, i)
  }
  return byID
}

function* iterateCodes(codes) {
  for (const code of codes) {
    yield [code, undefined]
  }
}

const accessMethods = {
  read: ['select'],
  crud: ['select', 'insert', 'update', 'delete', 'addnew'],
  write: ['insert', 'update', 'delete', 'addnew'],
  read_update: ['select', 'update'],
  read_insert_update: ['select', 'insert', 'update', 'addnew'],
  full: ['*']
}

/**
 * @param {Array<string>|null} methods
 * @return {string|null}
 */
function buildMethodMask(methods) {
  if (methods == null) {
    return null
  }

  if (methods.length === 1) {
    return methods[0]
  }

  const firstLetters = methods.map(m => m[0])
  return '[' + [...new Set(firstLetters)].sort().join('') + ']*'
}

function* enumerateRules(els) {
  for (const [accType, methodsList] of Object.entries(accessMethods)) {
    if (els.hasOwnProperty(accType)) {
      const accessMethodsMask = buildMethodMask(methodsList)

      // Assume elements of array are model names for that access type
      for (const acc of stringToArray(els[accType])) {
        let scope, entityMask, methodMask, ruleType
        if (acc.indexOf('.') !== -1) {
          // Access to individual methods
          entityMask = acc.substr(0, acc.indexOf('.'))
          methodMask = acc.substr(acc.indexOf('.') + 1)
          scope = 'method'
        } else {
          methodMask = accessMethodsMask
          entityMask = acc
          scope = entityMask.indexOf('_') === -1 ? 'model' : 'entity'
        }

        if (entityMask.indexOf('_') === -1) {
          entityMask = entityMask + '_*'
        }

        if (entityMask[0] === '!') {
          entityMask = entityMask.substring(1)
          ruleType = 'D'
        }

        yield [undefined, {acc, accType, scope, entityMask, methodMask, ruleType}]
      }
    }
  }

  if (els.custom) {
    for (let [key, value] of iterateList(els.custom)) {
      let entityMask, methodMask, code, description, ruleType

      if (value === undefined) {
        // A string value with dot separating entityMask and methodMask
        const index = key.indexOf('.')
        entityMask = key.substr(0, index)
        methodMask = key.substr(index + 1)
      } else {
        const valueParts = value.split(',').map(s => s.trim())
        if (valueParts.length === 1) {
          entityMask = key
          methodMask = value
        } else {
          if (valueParts.length !== 2 && valueParts.length !== 3) {
            throw new Error(`Wrong format of custom ELS rule: ${value}`)
          }
          code = key
          entityMask = valueParts[0]
          methodMask = valueParts[1]
          description = valueParts[2]
        }
      }

      if (entityMask[0] === '!') {
        entityMask = entityMask.substring(1)
        ruleType = 'D'
      }

      yield [undefined, {entityMask, methodMask, code, description, ruleType}]
    }
  }
}

/**
 * @param {{name: string, firstName: string, lastName: string}} obj
 * @return {string}
 */
function buildFullName(obj) {
  return obj.firstName && obj.lastName
    ? obj.firstName + ' ' + obj.lastName
    : obj.firstName
      ? obj.firstName
      : obj.lastName
        ? obj.lastName
        : obj.name
}

module.exports = function (container, domainInfo) {
  const shortcutAdmEntityName = getAdmEntityName(domainInfo, 'ubm_navshortcut')
  const shortcutAdm = new EntityFormat()
    .key('shortcut')
    .fromContext({subject: 'role'})
    .wrapAsEntity(shortcutAdmEntityName)

  const desktopAdmEntityName = getAdmEntityName(domainInfo, 'ubm_desktop')
  const desktopAdm = new EntityFormat()
    .key('desktop')
    .fromContext({subject: 'role'})
    .wrapAsEntity(desktopAdmEntityName)

  container.registerFileType(
    'roles',
    new EntityFormat()
      .key('name')
      .caption('description')
      .copy('sessionTimeout', 'allowedAppMethods')
      .transform('allowedAppMethods', val => stringToArray(val).join(','))
      .wrapAsEntity('uba_role')
      .child(
        'els',
        {
          context: {
            roleCode: 'name'
          },
          iterate(els, ctx) {
            const source = enumerateRules(els)
            return transform(
              source,
              new EntityFormat()
                .fromContext({ruleRole: 'roleCode'})
                .copy('entityMask', 'methodMask', 'code', 'description', 'ruleType')
                .defaultValue('ruleType', 'A')
                .defaultValue('code', buildElsCode)
                .defaultValue('description', buildElsDescription)
                .wrapAsEntity('uba_els'),
              ctx
            )
          }
        })
      .child(
        'shortcuts',
        {
          context: {
            role: 'name'
          },

          iterate: function* (shortcutMasks, ctx) {
            for (const shortcutMask of shortcutMasks) {
              // Replace * with [\w-]+
              const re = new RegExp('^' + shortcutMask.replace('*', '[\\w-]*') + '$', 'g')

              const ubmDesktop = container.getRepository('ubm_desktop')
              const ubmNavShortcut = container.getRepository('ubm_navshortcut')

              const desktopsByID = indexByID(ubmDesktop.getDbInstances(ctx.conn))
              const shortcutsByID = indexByID(ubmNavShortcut.getDbInstances(ctx.conn))

              const shortcutCodes = new Set()
              const desktopCodes = new Set()
              for (const instance of ubmNavShortcut.dbInstances) {
                if (instance.code.match(re)) {
                  shortcutCodes.add(instance.code)
                  const desktop = desktopsByID.get(instance.desktopID)
                  if (desktop) {
                    desktopCodes.add(desktop.code)
                  }
                  for (let parentInstance = instance;
                       parentInstance;
                       parentInstance = parentInstance && shortcutsByID.get(parentInstance.parentID)
                  ) {
                    shortcutCodes.add(parentInstance.code)
                  }
                }
              }

              for (const r of transform(iterateCodes(shortcutCodes), shortcutAdm, ctx)) {
                yield r
              }
              for (const r of transform(iterateCodes(desktopCodes), desktopAdm, ctx)) {
                yield r
              }
            }
          }
        }
      )
  )

  container.registerFileType(
    'groups',
    new EntityFormat()
      .key('code')
      .caption('name')
      .copy('description')
      .wrapAsEntity('uba_group')
      .child('roles', {
        context: {group: 'code'},
        iterate(val, ctx) {
          return transform(
            iterateChildren(val),
            new EntityFormat()
              .key('role')
              .fromContext({group: 'group'})
              .wrapAsEntity('uba_grouprole'),
            ctx
          )
        }
      })
      .child('users', {
        context: {group: 'code'},
        iterate(val, ctx) {
          return transform(
            iterateChildren(val),
            new EntityFormat()
              .key('user')
              .fromContext({group: 'group'})
              .wrapAsEntity('uba_usergroup'),
            ctx
          )
        }
      }))

  container.registerFileType('users',
    new EntityFormat()
      .key('name')
      .caption('description')
      .copy('firstName', 'lastName', 'gender', 'email', 'phone', 'uData', 'disabled', 'password', 'trustedIP', 'lastPasswordChangeDate')
      .defaultValue('fullName', buildFullName)
      .wrapAsEntity('uba_user')
      .child('roles', {
        context: {
          user: 'name'
        },
        iterate(val, ctx) {
          return transform(
            iterateChildren(val),
            new EntityFormat()
              .key('role')
              .fromContext({user: 'user'})
              .wrapAsEntity('uba_userrole'),
            ctx
          )
        }
      })
      .child('groups', {
        context: {user: 'name'},
        iterate(val, ctx) {
          return transform(
            iterateChildren(val),
            new EntityFormat()
              .key('group')
              .fromContext({user: 'user'})
              .wrapAsEntity('uba_usergroup'),
            ctx
          )
        }
      })
  )

  container.registerRepository(
    new NonCachedEntityRepository(
      'uba_subject',
      ['code']
    )
  )

  const ubaRole = new EntityRepository(
    'uba_role',
    ['name'],
    ['allowedAppMethods'],
    ['description'],
    undefined,
    undefined,
    ['sessionTimeout']
  )
  ubaRole.on('update:before', ({execParams, dbInst}) => {
    // Append allowed app methods, do not rewrite it!
    if (execParams.allowedAppMethods && dbInst.allowedAppMethods && execParams.allowedAppMethods !== dbInst.allowedAppMethods) {
      const allAppMethods = [execParams, dbInst].map(inst => inst.allowedAppMethods.split(','))
      const uniqueMethods = new Set([].concat(...allAppMethods))
      execParams.allowedAppMethods = Array.from(uniqueMethods).join(',')
    }
  })
  container.registerRepository(ubaRole)

  const ubaUser = new EntityRepository(
    'uba_user',
    ['name'],
    ['description', 'firstName', 'lastName', 'fullName', 'email', 'phone', 'uData', 'disabled'],
    undefined,
    undefined,
    ['trustedIP', 'password', 'lastPasswordChangeDate']
  )
  ubaUser.on('insert:before', ({context, execParams}) => {
    if (execParams.password) {
      context.__tmpUbaUserPassword = execParams.password
      delete execParams.password
    }
  })
  ubaUser.on('insert:after', ({context, execParams}) => {
    if (context.__tmpUbaUserPassword) {
      context.conn.query({
        entity: 'uba_user',
        method: 'changeOtherUserPassword',
        execParams: {
          newPwd: context.__tmpUbaUserPassword,
          forUser: execParams.name
        }
      })
      delete context.__tmpUbaUserPassword
    }
  })
  container.registerRepository(ubaUser)

  container.registerRepository(
    new NonCachedEntityRepository(
      'uba_userrole',
      ['userID', 'roleID'],
      [],
      [],
      [
        {repository: ubaUser, attribute: 'user', targetAttribute: 'userID'},
        {repository: ubaRole, attribute: 'role', targetAttribute: 'roleID'}
      ]
    )
  )

  container.registerRepository(
    new EntityRepository(
      'uba_els',
      ['code'],
      ['description', 'entityMask', 'methodMask', 'ruleType', 'ruleRole'],
      [],
      [
        {repository: ubaRole, attribute: 'ruleRole'}
      ]
    )
  )

  const ubaGroup = new EntityRepository(
    'uba_group',
    ['code'],
    ['description'],
    ['name']
  )
  container.registerRepository(ubaGroup)

  container.registerRepository(
    new NonCachedEntityRepository(
      'uba_grouprole',
      ['groupID', 'roleID'],
      [],
      [],
      [
        {repository: ubaGroup, attribute: 'group', targetAttribute: 'groupID'},
        {repository: ubaRole, attribute: 'role', targetAttribute: 'roleID'}
      ]
    )
  )

  container.registerRepository(
    new NonCachedEntityRepository(
      'uba_usergroup',
      ['userID', 'groupID'],
      [],
      [],
      [
        {repository: ubaUser, attribute: 'user', targetAttribute: 'userID'},
        {repository: ubaGroup, attribute: 'group', targetAttribute: 'groupID'}
      ]
    )
  )
}
