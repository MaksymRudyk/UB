const {EntityRepository} = require('../metadata/entity-repository')
const {EntityFormat} = require('../metadata/entity-format')
const {flatMap} = require('./utility')

class Container {
  /**
   *
   * @param {MigrationOptions} options
   */
  constructor(options= {}) {
    this._options = options

    /**
     * @type {Map<string, EntityFormat>}
     */
    this._fileTypes = new Map()

    /**
     *
     * @type {Map<string, BaseRepository>}
     */
    this._repositories = new Map()
  }

  /**
   * @param {string} fileType
   * @param {EntityFormat} md
   */
  registerFileType(fileType, md) {
    if (!this._options.silent) {
      console.log('Registering file type: %s', fileType)
    }
    this._fileTypes.set(fileType, md)
  }

  /**
   * @param {string} entityName
   * @return {EntityFormat}
   */
  getFileType(entityName) {
    const fileType = this._fileTypes.get(entityName)
    if (!fileType) {
      throw new Error(`File type "${entityName}" is not registered`)
    }
    return fileType
  }

  /**
   * @param {string|BaseRepository} entityName
   * @param {BaseRepository} [repository]
   */
  registerRepository(entityName, repository) {
    if (typeof entityName !== 'string' && repository === undefined) {
      // Set entityName from inside repository, allowing register repository without explicitly specifying entity name
      repository = entityName
      entityName = repository.entity
    } else if (repository.entity === entityName && !this._options.silent) {
      console.log('registerRepository.registerRepository does not need first argument for its call for entity: %s', entityName)
    }

    repository.attachToContainer(this)

    if (!this._options.silent) {
      console.log('Registering repository: %s', entityName)
    }
    this._repositories.set(entityName, repository)
  }

  /**
   * @param {string} entityName
   * @return {BaseRepository}
   */
  getRepository(entityName) {
    const repo = this._repositories.get(entityName)
    if (!repo) {
      throw new Error(`Repository "${entityName}" is not registered`)
    }
    return repo
  }

  getAllRepositories() {
    return this._repositories.entries()
  }

  /**
   * Method 2 in 1: register data format for entity and at the same time register the entity repository.
   *
   * For more complex case, construct EntityRepository and EntityFormat separately and register using
   * `container.registerFileType` and `container.registerRepository`.
   *
   * @param {string} entityName
   * @param {string[]|string} keyAttributes
   * @param {string[]|string} regularAttributes=[]
   * @param {string[]|string} translatableAttributes=[]
   * @param {LookupDescriptorForExtend[]} [lookups]=[]
   * @param {string[]} [nonUpdatableAttributes]
   */
  registerEntity(
    entityName,
    keyAttributes,
    regularAttributes = [],
    translatableAttributes = [],
    lookups = [],
    nonUpdatableAttributes
  ) {
    if (typeof keyAttributes === 'string') {
      keyAttributes = [keyAttributes]
    }
    if (typeof regularAttributes === 'string') {
      regularAttributes = [regularAttributes]
    }
    if (typeof translatableAttributes === 'string') {
      translatableAttributes = [translatableAttributes]
    }
    for (const lookup of lookups) {
      if (typeof lookup.repository === 'string') {
        const repository = this.getRepository(lookup.repository)
        if (!repository) {
          throw new Error(
            `Cannot find repository name ${lookup.repository} during registering entity ${entityName}`
          )
        }
        lookup.repository = repository
      }
    }

    const repository = new EntityRepository(
      entityName,
      keyAttributes,
      regularAttributes,
      translatableAttributes,
      lookups,
      nonUpdatableAttributes
    )
    this.registerRepository(entityName, repository)

    const md = new EntityFormat()
    for (const attr of keyAttributes) {
      md.key(attr)
    }
    md.copy(...regularAttributes)
      .copy(...flatMap(lookups, la => la.attributes))
      .copy(...translatableAttributes)
      .wrapAsEntity(entityName)

    this.registerFileType(entityName, md)
  }
}

module.exports = {
  Container
}
