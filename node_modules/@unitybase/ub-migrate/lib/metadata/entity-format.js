const utility = require('./utility')

/**
 * @typedef {object} ParsedEntityInstance
 * @property {string} entity
 * @property {object} execParams
 */

/**
 * @typedef {object} UbMigrateDocumentAttrOptions
 * @property {string} [fileExtension]
 * @property {'utf8'|'bin'} [encoding]  Default is 'utf8'
 * @property {string} [relPath] For mdb store, a subfolder.  It will be combined with cust model name
 */

/**
 * Helper class to hold a string or array of strings for key attributes of an entity.
 */
class EntityFormat {
  /**
   * @param {string} entityName
   * @return {EntityFormat}
   */
  wrapAsEntity(entityName) {
    this.entityName = entityName
    return this
  }

  /**
   * @param {string} attr
   * @return {EntityFormat}
   */
  key(attr) {
    this.keyAttribute = attr
    return this
  }

  /**
   * @param {string} attr
   * @return {EntityFormat}
   */
  caption(attr) {
    return this.nonObjectValueAsAttribute(attr)
      .defaultValue(attr, obj => utility.codeToName(obj[this.keyAttribute]))
      .copy(attr)
  }

  /**
   * @param {...string} attrs
   * @return {EntityFormat}
   * @deprecated
   */
  translatable(...attrs) {
    console.warn('"translatable" call is obsolete for entity formats, they shall be done only for repositories, but for entity format %s, attributes %s still registered', this.entityName, attrs)
    return this
  }

  /**
   * @param {string} attr
   * @param {*|Function} value
   * @return {EntityFormat}
   */
  defaultValue(attr, value) {
    if (!this.defaultValues) {
      this.defaultValues = {}
    }
    this.defaultValues[attr] = value
    return this
  }

  /**
   * @param {object} value
   * @return {EntityFormat}
   */
  defaultChild(value) {
    this.defaultChildAttribute = value
    return this
  }

  /**
   * @param {...string} attrs
   * @return {EntityFormat}
   */
  copy(...attrs) {
    if (attrs && attrs.length) {
      this.copyAttributes = this.copyAttributes ? [...new Set(this.copyAttributes.concat(attrs))] : attrs
    }
    return this
  }

  /**
   * @param {...string|object} attrs
   * @return {EntityFormat}
   */
  fromContext(...attrs) {
    if (!this.contextAttributes) {
      this.contextAttributes = {}
    }
    for (const attr of attrs) {
      if (typeof attr === 'string') {
        this.contextAttributes[attr] = attr
      } else {
        for (const [ctxAttr, objAttr] of Object.entries(attrs[0])) {
          this.contextAttributes[ctxAttr] = objAttr
        }
      }
    }
    return this
  }

  /**
   * @param {string} attr
   * @return {EntityFormat}
   */
  nonObjectValueAsAttribute(attr) {
    this.defaultAttribute = attr
    return this
  }

  /**
   * @return {EntityFormat}
   */
  virtual() {
    this.isVirtual = true
    return this
  }

  /**
   * @param {string} attr
   * @param {Function} func
   * @return {EntityFormat}
   */
  transform(attr, func) {
    if (!this.transformAttributes) {
      this.transformAttributes = {}
    }
    this.transformAttributes[attr] = func
    return this
  }

  /**
   * @param {string} attr
   * @param {UbMigrateDocumentAttrOptions} options
   * @return {EntityFormat}
   */
  document(attr, options) {
    if (!this.documentAttributes) {
      this.documentAttributes = {}
    }
    this.documentAttributes[attr] = options
    return this
  }

  /**
   * @param {string} attr
   * @param {number} delta
   * @return {EntityFormat}
   */
  autoNumber(attr, delta = 10) {
    return this
      .defaultValue(attr, (obj, ctx) => {
        if (!ctx.hasOwnProperty('sortOrder')) {
          ctx.sortOrder = delta
        }
        return ctx.sortOrder
      })
      .copy(attr)
      .transform(attr, (val, ctx) => {
        ctx.sortOrder = val + 10
        return val
      })
  }

  /**
   * @param {string} attr
   * @param {object} childDescriptor
   * @return {EntityFormat}
   */
  child(attr, childDescriptor) {
    if (!this.childCollections) {
      this.childCollections = {}
    }
    if (childDescriptor.metadata === '$self') {
      childDescriptor.metadata = this
    }
    this.childCollections[attr] = childDescriptor
    return this
  }

  /**
   * Check if attribute name is the key attribute name
   * @param {string} attrName
   * @return {boolean}
   */
  isKeyAttribute(attrName) {
    if (Array.isArray(this.keyAttribute)) {
      return this.keyAttribute.indexOf(attrName) !== -1
    }
    return attrName === this.keyAttribute
  }

  /**
   * @return {Array<string>}
   */
  getKeyAttributes() {
    return Array.isArray(this.keyAttribute)
      ? this.keyAttribute
      : [this.keyAttribute]
  }
}

module.exports = {EntityFormat}
