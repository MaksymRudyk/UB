EventEmitter = require('events')
const {zipObject, isEqual} = require('lodash')
const {UBDomain} = require('@unitybase/cs-shared')

const {
  FILE_ENCODING,
  FILE_CONTENT,
  FILE_NAME,
  FILE_EXTENSION,
  FILE_REL_PATH
} = require('./file-instructions')

/**
 * @typedef {object} LookupDescriptor
 * @property {BaseRepository|string|'$self'} repository
 * @property {string} [attribute]
 * @property {string[]} [attributes]
 * @property {string} [targetAttribute]
 */

/**
 * @typedef {object} LookupDescriptorForExtend
 * @property {BaseRepository} repository
 * @property {string[]} [attributes]
 * @property {string} [targetAttribute]
 */

/**
 * Repository class is responsible for:
 * - insert or update
 * - handle lookups
 * - substituteLookups
 * - fromDefinition(key, value)
 */
class BaseRepository extends EventEmitter {
  /**
   * @param {string} entity
   * @param {string[]} keyAttributes
   * @param {string[]} [regularAttributes]
   * @param {string[]} [multiLangAttributes]
   * @param {LookupDescriptor[]} [lookups]
   * @param {string[]} [nonUpdatableAttrs]
   */
  constructor(entity, keyAttributes, regularAttributes, multiLangAttributes, lookups, nonUpdatableAttrs) {
    super()
    this.entity = entity
    this.keyAttributes = keyAttributes

    /**
     * @type {string[]}
     */
    this.regularAttributes = regularAttributes || []

    this.multiLangAttributes = multiLangAttributes || []
    this.lookups = lookups || []
    for (const l of this.lookups) {
      this._resolveLookupProps(l)
    }
    this.nonUpdatableAttrs = nonUpdatableAttrs || []
  }

  /**
   * @return {string[]}
   */
  get selectableAttributes() {
    const attrs = this.updatableAttributes.concat('ID', this.keyAttributes)
    return [...new Set(attrs)]
  }

  /**
   * @return {string[]}
   */
  get updatableAttributes() {
    return this.regularAttributes.concat(
      ...this.multiLangAttributes.map(a => this.langConfig.supportLang.map(l => `${a}_${l}^`)),
      ...this.lookups.map(l => l.targetAttribute).filter(attr => !!attr)
    )
  }

  init(langConfig) {
    this.langConfig = langConfig
  }

  attachToContainer(container) {
    this.container = container

    // Resolve repositories specified as string
    for (const l of this.lookups) {
      this._resolveLookupProps(l)
    }
  }

  registerLookup(l) {
    this._resolveLookupProps(l)
    this.lookups.push(l)
  }

  lookup(conn, keyAttrValues) {
    // Implement in inherited classes
  }

  updateCache(operationResult) {
    // Implement in inherited classes, if they need maintain cache after insert or update of instance
  }

  /**
   * @return {Array}
   */
  getKeyAttributesValues(execParams) {
    return this.keyAttributes.map(ka => execParams[ka])
  }

  /**
   * @param inst
   * @param {MigrationContext} context
   */
  save(inst, context) {
    const entityInfo = context.domainInfo.get(this.entity)
    const execParams = this._substituteLookups(context.conn, entityInfo, inst)

    this.emit('save:before', {context, execParams})
    const dbInst = this.lookup(context.conn, ...this.getKeyAttributesValues(execParams))
    let operationResult
    let fieldList
    if (dbInst) {
      execParams.ID = dbInst.ID
      this.emit('update:before', {context, execParams, dbInst})

      const attrsToUpdate = this.updatableAttributes.filter(attr => {
        const isDocument =
          !attr.endsWith('^') &&
          entityInfo.getAttribute(attr).dataType === UBDomain.ubDataTypes.Document
        if (isDocument && execParams.hasOwnProperty(attr) && dbInst[attr]) {
          // Substitute document info with document content - for comparison
          // Only if execParams contains it, only if dbInst has document filled
          const docRequest = {
            entity: this.entity,
            attribute: attr,
            id: dbInst.ID
          }
          try {
            dbInst[attr] = context.conn.getDocument(docRequest, {resultIsBinary: true})
          } catch (e) {
            console.error(
              'Error getting document using request: %s.  Assuming need to re-save the document value',
              JSON.stringify(docRequest)
            )
            return true
          }

          let content = execParams[attr][FILE_CONTENT]
          if (typeof content === 'object') {
            content = JSON.stringify(content)
          }

          if (typeof content === 'string') {
            const contentAsUint8 = new Uint8Array(content.split('').map(char => char.charCodeAt(0)))
            const dbValueAsUint8 = new Uint8Array(dbInst[attr])

            if (contentAsUint8.length !== dbValueAsUint8.length) {
              return true
            }
            for (let i = 0; i < contentAsUint8.length; i++) {
              if (contentAsUint8[i] !== dbValueAsUint8[i]) {
                return true
              }
            }
            return false
          }
        }
        const attrObj = entityInfo.attributes[attr]
        if (attrObj && attrObj.dataType === UBDomain.ubDataTypes.Boolean) {
          if (execParams[attr] !== undefined) {
            // Convert boolean value to number, because in DB it is stored as number 
            execParams[attr] = execParams[attr] ? 1 : 0
          }
        }

        if (attrObj && attrObj.dataType === UBDomain.ubDataTypes.Json && dbInst[attr] && execParams[attr]) {
          // Custom comparison for JSON, because some DBMS alters original formatting,
          // which make equal JSON look unequal
          const dbJsonValue = JSON.parse(dbInst[attr])
          const epJsonValue = JSON.parse(execParams[attr])
          return !isEqual(dbJsonValue, epJsonValue)
        }

        if (dbInst[attr] === execParams[attr]) {
          return false
        }

        if (context.options.verbose) {
          console.debug('%s: execParams=%j | db=%j', attr, execParams[attr], dbInst[attr])
        }

        if (execParams[attr] === undefined) {
          // Check if value match the attribute default value
          if (!attrObj || !attrObj.defaultValue) {
            // Oops, no default value for attribute
            return true
          }

          const attrDefaultValue = defaultValueTyped(attrObj)
          if (context.options.verbose) {
            console.debug('defaultValueTyped: %j', attrDefaultValue)
          }

          if (attrDefaultValue === dbInst[attr]) {
            // Skip updating in case passed value is not defined and default attribute value === value in DB
            return false
          }
        }

        if (context.options.verbose) {
          console.debug('%s: diff for %s: db=%j should be %j', this.entity, attr, dbInst[attr], execParams[attr])
        }

        return true
      })

      if (attrsToUpdate.length > 0) {
        if (!context.options.silent) {
          console.log('Update %s %s', this.entity, execParams.code || execParams.name || execParams.caption || '')
        }

        const updateExecParams = {ID: dbInst.ID}
        for (const attr of attrsToUpdate) {
          if (context.options.verbose) {
            console.log(`\t${attr}: "${dbInst[attr]}" => "${execParams[attr]}"`)
          }
          updateExecParams[attr] = execParams[attr]
        }

        // Some attribute must not be updated, once in DB, for example ubs_setting.settingValue
        for (const attr of this.nonUpdatableAttrs) {
          delete execParams[attr]
          for (const lang of this.langConfig.supportLang) {
            delete execParams[`${attr}_${lang}^`]
          }
        }

        this._setDocuments(context.conn, entityInfo, execParams, context.defaultCustomerModel)
        fieldList = buildFieldList(execParams)
        operationResult = context.conn.update({
          entity: inst.entity,
          fieldList,
          execParams,
          __skipOptimisticLock: true
        })
        if (operationResult && operationResult.data) {
          operationResult = operationResult.data[0]
        }

        context.stats.totalUpdates++
        this.emit('update:after', {
          context,
          execParams,
          dbInst,
          resultData: operationResult
        })
      } else {
        context.stats.totalSkippedUpdates++
        this.emit('update:skip', {
          context,
          execParams,
          dbInst
        })
      }
    } else {
      this.emit('insert:before', {
        context,
        execParams
      })
      if (!context.options.silent) {
        console.log(
          `Insert ${this.entity} ${execParams.code || execParams.name || execParams.caption || ''}`
        )
      }
      this._setDocuments(context.conn, entityInfo, execParams, context.defaultCustomerModel)
      fieldList = buildFieldList(execParams)
      operationResult = context.conn.insert({
        entity: inst.entity,
        fieldList,
        execParams
      })
      context.stats.totalInserts++
      this.emit('insert:after', {
        context,
        execParams,
        resultData: operationResult
      })
    }

    if (operationResult) {
      this.updateCache(zipObject(fieldList, operationResult))
    }
  }

  /**
   * Called on save, replace lookup by corresponding IDs.
   * @param {SyncConnection} conn
   * @param {UBEntity} entityInfo
   * @param {object} inst
   * @private
   */
  _substituteLookups(conn, entityInfo, inst) {
    const execParams = Object.assign({}, inst.execParams)
    for (const lookup of this.lookups) {
      const targetAttr = lookup.targetAttribute || lookup.attributes[0]
      const attrInfo = entityInfo.getAttribute(targetAttr)
      const lookupAttrValues = lookup.attributes.map(la => execParams[la])

      if (attrInfo.dataType === UBDomain.ubDataTypes.Many) {
        // Many value
        if (lookupAttrValues.every(v => Array.isArray(v))) {
          const count = Math.min(...lookupAttrValues.map(v => v.length))
          const otherEntityIDs = []
          for (let i = 0; i < count; i++) {
            const otherEntityKeys = lookupAttrValues.map(v => v[i])
            const otherEntity = lookup.repository.lookup(conn, ...otherEntityKeys)
            if (otherEntity == null) {
              throw new Error(
                `Cannot lookup entity ${lookup.repository.entity} by key values ${otherEntityKeys.join(',')}`
              )
            }
            otherEntityIDs.push(otherEntity.ID)
          }
          execParams[targetAttr] = otherEntityIDs.join(',')
        }

      } else {
        // Scalar value
        if (lookupAttrValues.some(v => v != null)) {
          const otherEntity = lookup.repository.lookup(conn, ...lookupAttrValues)
          if (otherEntity == null) {
            throw new Error(
              `Cannot lookup entity ${lookup.repository.entity} by key values ${lookupAttrValues.join(',')}`
            )
          }
          execParams[targetAttr] = otherEntity.ID
        }
      }

      for (const lookupAttr of lookup.attributes) {
        if (lookupAttr !== targetAttr) {
          delete execParams[lookupAttr]
        }
      }
    }
    return execParams
  }

  /**
   * Save document attributes content
   * @param {SyncConnection} conn
   * @param {UBEntity} entityInfo
   * @param {object} execParams
   * @param {string} defaultCustomerModel
   * @private
   */
  _setDocuments(conn, entityInfo, execParams, defaultCustomerModel) {
    for (const attr of Object.keys(execParams)) {
      if (attr.endsWith('^')) {
        continue
      }

      const attrInfo = entityInfo.getAttribute(attr)
      if (attrInfo.dataType !== UBDomain.ubDataTypes.Document) {
        continue
      }

      if (!Number.isInteger(execParams.ID)) {
        // Need to generate new ID
        const result = conn.query({
          entity: entityInfo.name,
          method: 'addnew',
          fieldList: ['ID']
        })
        execParams.ID = result.resultData.data[0][0]
      }

      let content = execParams[attr]
      let fileExtension = '.txt'
      let fileName, relPath
      let encoding = 'utf8'

      if (typeof content === 'object' && content !== null) {
        if (content[FILE_NAME]) {
          fileName = content[FILE_NAME]
        } else if (content[FILE_EXTENSION]) {
          fileExtension = content[FILE_EXTENSION]
        }
        if (content[FILE_ENCODING]) {
          encoding = content[FILE_ENCODING]
        }
        if (content[FILE_REL_PATH]) {
          relPath = content[FILE_REL_PATH]
        }
        if (content[FILE_CONTENT]) {
          content = content[FILE_CONTENT]
        }
      }

      if (!fileName) {
        fileName = entityInfo.code + '-' + execParams.ID + '-' + attr + fileExtension
      }

      execParams[attr] = conn.setDocument(
        entityInfo.code,
        attr,
        execParams.ID,
        content,
        fileName,
        encoding
      )

      if (relPath) {
        if (relPath.indexOf('|') === -1) {
          relPath = defaultCustomerModel + '|' + relPath
        }
        const parsedDocAttr = JSON.parse(execParams[attr])
        parsedDocAttr.relPath = relPath
        execParams[attr] = JSON.stringify(parsedDocAttr)
      }
    }
  }

  _resolveLookupProps(l) {
    if (l.repository === '$self') {
      l.repository = this
    }
    if (this.container && typeof l.repository === 'string') {
      l.repository = this.container.getRepository(l.repository)
    }
    if (typeof l.attribute === 'string' && !Array.isArray(l.attributes)) {
      l.attributes = [l.attribute]
      delete l.attribute
    }
  }
}

class EntityRepository extends BaseRepository {
  init(langConfig) {
    super.init(langConfig)
    this.dbInstances = null
  }

  getDbInstances(conn) {
    if (!this.dbInstances) {
      this._load(conn)
    }
    return this.dbInstances
  }

  lookup(conn, ...keyAttrValues) {
    return this.getDbInstances(conn).find(e => {
      let i = 0
      for (const keyAttr of this.keyAttributes) {
        if (e[keyAttr] !== keyAttrValues[i++]) {
          return false
        }
      }
      return true
    })
  }

  updateCache(operationResult) {
    // Implement in inherited classes, if they need maintain cache after insert or update of instance
    const dbInst = this.lookup(null, ...this.getKeyAttributesValues(operationResult))
    if (dbInst) {
      Object.assign(dbInst, operationResult)
    } else {
      this.dbInstances.push(operationResult)
    }
  }

  _load(conn) {
    this.dbInstances = conn.Repository(this.entity).attrs(this.selectableAttributes).selectAsObject()

    for (const dbInstance of this.dbInstances) {
      for (const key of Object.keys(dbInstance)) {
        if (dbInstance[key] === null) {
          delete dbInstance[key]
        }
      }
    }
  }
}

class NonCachedEntityRepository extends BaseRepository {
  lookup(conn, ...keyAttrValues) {
    let i = 0
    const repo = conn.Repository(this.entity).attrs(...this.selectableAttributes)
    for (const keyAttr of this.keyAttributes) {
      const value = keyAttrValues[i++]
      repo.whereIf(value !== undefined, keyAttr, '=', value)
    }
    return repo.selectSingle()
  }
}

function buildFieldList(execParams) {
  const fieldList = Object.keys(execParams)
  if (fieldList.indexOf('ID') === -1) {
    fieldList.push('ID')
  }
  return fieldList
}

/**
 * Return default attribute value converted into attribute type or `undefined` in case defaultValue is not defined
 * @param {UBEntityAttribute} attr
 * @returns {*}
 * @private
 */
function defaultValueTyped(attr) {
  if (!attr.defaultValue) {
    return undefined
  }

  switch (attr.dataType) {
    case UBDomain.ubDataTypes.Int:
    case UBDomain.ubDataTypes.BigInt:
    case UBDomain.ubDataTypes.Float:
    case UBDomain.ubDataTypes.Currency:
    case UBDomain.ubDataTypes.ID:
    case UBDomain.ubDataTypes.Entity:
      return parseFloat(attr.defaultValue)

    case UBDomain.ubDataTypes.Boolean:
      return attr.defaultValue === '1' || attr.defaultValue === 'true' ? 1 : 0

    case UBDomain.ubDataTypes.DateTime:
    case UBDomain.ubDataTypes.Text:
    case UBDomain.ubDataTypes.Document:
    case UBDomain.ubDataTypes.Many:
    case UBDomain.ubDataTypes.TimeLog:
    case UBDomain.ubDataTypes.Enum:
    case UBDomain.ubDataTypes.BLOB:
    case UBDomain.ubDataTypes.Date:
    case UBDomain.ubDataTypes.Json:
      return attr.defaultValue

    default:
      return undefined
  }
}

module.exports = {
  EntityRepository,
  NonCachedEntityRepository
}
