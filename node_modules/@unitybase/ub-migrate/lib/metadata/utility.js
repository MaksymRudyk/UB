const path = require('path')
const fs = require('fs')
const {snakeCase, capitalize} = require('lodash')

const {
  FILE_ENCODING,
  FILE_CONTENT,
  FILE_NAME,
  FILE_EXTENSION,
  FILE_REL_PATH
} = require('./file-instructions')

module.exports = {
  iterateList,
  processList,
  transform,
  transformAndTranslate,
  addTranslations,

  flatMap,
  stringToArray,
  iterateChildren,
  codeToName,

  arrayItemsOrSelf,
  keyValueEntries,

  getAdmEntityName
}

/**
 * @typedef {object} UbMigrateFileAttrObjValue
 * @property {string} [$file]
 *   If set, content will be read from the specified file.  File name is relative to the file it is declared in.
 *   Option is incompatible with $content.
 *   File name passed to "setDocument" will default to the file name.  But it is possible to override an extension and/or
 *   file name using $fileName or $fileExtension option.
 * @property {string} [$encoding]
 *   Encoding to be used to read file and while call of "setDocument" UB endpoint.
 * @property {string} [$fileName]
 *   Option is incompatible with $fileExtension.  If specified, the file name will be used in "setDocument" call.
 * @property {string} [$fileExtension]
 *   Option is incompatible with $fileName.  Extension will be changed even, when $file is used.
 * @property {string} [$content]
 *   A string or an object with content.
 *   If an object and extension is not set, it defaults to ".json"
 *   Option is not compatible with $file
 */

/**
 * Convert string, object array of strings, array of objects, mixed array of strings and objects
 * into a flat iterable of key-value pairs, string counts as key-undefined pair.
 * This allows flexibility and user-friendly way of defining objects, not sticking to just one way of defining objects.
 * @param {string|object|Array<string|object>} data
 * @return {IterableIterator<Array>}
 */
function* iterateList(data) {
  for (const item of arrayItemsOrSelf(data)) {
    for (const entry of keyValueEntries(item)) {
      yield entry
    }
  }
}

/**
 * Enumerate array items.  For non-array argument, iterate the argument.
 * @param {Array|object} arrayOrObject
 * @return {IterableIterator<*>}
 */
function* arrayItemsOrSelf(arrayOrObject) {
  if (Array.isArray(arrayOrObject)) {
    for (const item of arrayOrObject) {
      yield item
    }
  } else {
    yield arrayOrObject
  }
}

/**
 * Treat a string as a single key-value, with value=undefined.
 * For objects, enumerate kev-value entries.
 * @param {Object|string} objOrString
 * @return {Array<Array>}
 */
function keyValueEntries(objOrString) {
  return typeof objOrString === 'string'
    ? [[objOrString, undefined]]
    : Object.entries(objOrString)
}

/**
 * Iterate though key-value pairs and delegate call to processing function, and provide to it a context.
 * Take care about context switching instructions which may be present inside the list as entry with a "$context" key
 * It creates a child context, which is passed to the processing function.
 * @param {IterableIterator<Array>} source
 * @param {Function} func
 * @param {MigrationContext} ctx
 * @return {IterableIterator<*>}
 */
function* processList(source, func, ctx) {
  let context = ctx
  for (const [key, value] of source) {
    if (key === '$context') {
      context = Object.create(ctx)
      Object.assign(context, value)
    } else {
      const res = func(key, value, context)
      if (res !== undefined) {
        if (typeof res[Symbol.iterator] === 'function') {
          for (const r of res) {
            yield r
          }
        } else {
          yield res
        }
      }
    }
  }
}

/**
 * @param {IterableIterator<Array>} source
 * @param {EntityFormat} md
 * @param {MigrationContext} ctx
 * @param {string} [fileName]
 * @return {IterableIterator<*>}
 */
function* transformAndTranslate(source, md, ctx, fileName) {
  for (const item of transform(source, md, ctx, fileName)) {
    addTranslations(item, ctx)
    yield item
  }
}

const ASSIGNED_DEFAULT_VALUES = Symbol('ASSIGNED_DEFAULT_VALUES')

/**
 * @param {IterableIterator<Array>} source
 * @param {EntityFormat} md
 * @param {MigrationContext} ctx
 * @param {string} [fileName]
 * @return {IterableIterator<*>}
 */
function* transform(source, md, ctx, fileName) {
  const repository = md.entityName && ctx.container.getRepository(md.entityName)
  const multiLangAttributes = repository && repository.multiLangAttributes || []

  for (let [key, value] of source) {
    const obj = {}
    if (md.keyAttribute) {
      obj[md.keyAttribute] = key
    }
    if (value == null) {
      value = {}
    }
    if (typeof value !== 'object') {
      value = md.defaultAttribute ? {[md.defaultAttribute]: value} : {}
    } else if (md.defaultAttribute && value[md.defaultAttribute] === undefined && ctx.langConfig) {
      // Handle cases, when code-name data structures with no other attributes are defined using shorthand syntax like
      // code: {en: En value, uk: Uk value}
      const hasNoExplicitValue = value[md.defaultAttribute] === undefined
      const isTranslatable = multiLangAttributes.indexOf(md.defaultAttribute) !== -1
      if (isTranslatable && hasNoExplicitValue) {
        let explicitValue
        for (const lang of ctx.langConfig.supportLang) {
          if (value[lang] !== undefined) {
            if (!explicitValue) {
              explicitValue = value[md.defaultAttribute] = {}
            }
            explicitValue[lang] = value[lang]
            delete value[lang]
          }
        }
      }
    }

    // "defaultChild" is used for ubm_enum (enum group / items in yaml => flat ubm_enum)
    if (!md.defaultChildAttribute) {
      if (md.keyAttribute) {
        value[md.keyAttribute] = key
      }
      if (Array.isArray(md.copyAttributes)) {
        for (const attr of md.copyAttributes) {
          if (value[attr] !== undefined) {
            obj[attr] = value[attr]
          }
        }
      }
      if (Array.isArray(md.contextAttributes)) {
        for (const attr of md.contextAttributes) {
          if (ctx[attr] !== undefined) {
            obj[attr] = ctx[attr]
          }
        }
      } else if (typeof md.contextAttributes === 'object') {
        for (const [attr, contextAttr] of Object.entries(md.contextAttributes)) {
          if (ctx[contextAttr] !== undefined) {
            obj[attr] = ctx[contextAttr]
          }
        }
      }
      if (md.defaultAttribute && value[md.defaultAttribute] !== undefined) {
        obj[md.defaultAttribute] = value[md.defaultAttribute]
      }
      if (md.defaultValues && !value['$noDefaults']) {
        for (const [attr, defaultValue] of Object.entries(md.defaultValues)) {
          if (obj[attr] === undefined) {
            if (typeof defaultValue === 'function') {
              const calculatedDefaultValue = defaultValue(value, ctx)
              if (calculatedDefaultValue !== undefined) {
                obj[attr] = calculatedDefaultValue
              }
            } else {
              obj[attr] = defaultValue
            }

            const isTranslatable = multiLangAttributes.indexOf(attr) !== -1
            if (isTranslatable) {
              // Register the attr as having a default value
              if (!obj[ASSIGNED_DEFAULT_VALUES]) {
                obj[ASSIGNED_DEFAULT_VALUES] = {}
              }
              obj[ASSIGNED_DEFAULT_VALUES][key] = true
            }
          }
        }
      }
      if (md.transformAttributes) {
        for (const [key, value] of Object.entries(md.transformAttributes)) {
          if (obj[key] !== undefined) {
            obj[key] = value(obj[key], ctx)
          }
        }
      }
      if (md.documentAttributes) {
        for (const [key, attrConfig] of Object.entries(md.documentAttributes)) {
          /**
           * @type {UbMigrateFileAttrObjValue|string|null|undefined}
           */
          let attrValue = obj[key]

          if (attrValue == null) {
            // null or undefined, do nothing, no value will be set
            continue
          }

          const fileAttrValue = {}
          if (attrConfig.encoding) {
            fileAttrValue[FILE_ENCODING] = attrConfig.encoding
          }
          if (attrConfig.fileExtension) {
            fileAttrValue[FILE_EXTENSION] = attrConfig.fileExtension
          }
          if (attrConfig.relPath) {
            fileAttrValue[FILE_REL_PATH] = attrConfig.relPath
          }
          if (typeof attrValue === 'string') {
            fileAttrValue[FILE_CONTENT] = attrValue
          } else if (typeof attrValue === 'object') {

            if (attrValue.$fileExtension) {
              if (attrValue.$fileName) {
                delete attrValue.$fileExtension
                if (!ctx.options.silent) {
                  console.warn(
                    'Both $fileName and $fileExtension specified for Document attribute %s, ' +
                    '$fileExtension is ignored',
                    key
                  )
                }
              }
            }

            if (attrValue.$fileName) {
              fileAttrValue[FILE_NAME] = attrValue.$fileName
              delete fileAttrValue[FILE_EXTENSION]
            }

            if (attrValue.$encoding) {
              fileAttrValue[FILE_ENCODING] = attrValue.$encoding
            }

            // Either it is a content as object, in such a case just set
            if (attrValue.$file) {
              if (attrValue.$content) {
                throw new Error(
                  '$file and $content directive specified for the "' + key +
                  '" attribute.  Can use only one of the options.'
                )
              }

              if (!fileName) {
                throw new Error(
                  '$file directive is only allowed, when parse from a file, ' +
                  'because $file is relative to a directory of the file it is used in'
                )
              }

              const filePath = path.dirname(fileName)
              const {dir, base, name, ext} = path.parse(attrValue.$file)
              const encoding = fileAttrValue[FILE_ENCODING] || 'utf8'

              const contentSourcePath = path.join(filePath, dir, base)
              if (ctx.options.verbose) {
                console.log('Reading file content from file: %s, using encoding "%s"...', contentSourcePath, encoding)
              }

              fileAttrValue[FILE_CONTENT] = fs.readFileSync(contentSourcePath, {encoding})
              if (!fileAttrValue[FILE_NAME]) {
                fileAttrValue[FILE_NAME] = attrValue.$fileName || name + (attrValue.$fileExtension || ext)
              }

            } else if (attrValue.$content) {
              if (typeof attrValue.$content === 'string') {
                fileAttrValue[FILE_CONTENT] = attrValue.$content
              } else if (typeof attrValue.$content === 'object') {
                fileAttrValue[FILE_CONTENT] = JSON.stringify(attrValue.$content)
                if (!fileAttrValue[FILE_EXTENSION] && !fileAttrValue[FILE_NAME]) {
                  // If no file extension is configured, smart-default to ".json"
                  fileAttrValue[FILE_EXTENSION] = '.json'
                }
              } else {
                throw new Error('$content must be string or object with data, but it was ' + JSON.stringify(attrValue.$content))
              }
            } else {
              // attrValue is an object, but neither $file / $content specified.
              if (attrValue.$fileExtension || attrValue.$fileName || attrValue.$encoding) {
                throw new Error('$content or $file must be specified')
              }

              // No special attributes found, treat it as just a content
              fileAttrValue[FILE_CONTENT] = JSON.stringify(attrValue.$content)
              if (!fileAttrValue[FILE_EXTENSION] && !fileAttrValue[FILE_NAME]) {
                // If no file extension is configured, smart-default to ".json"
                fileAttrValue[FILE_EXTENSION] = '.json'
              }
            }
          }

          obj[key] = fileAttrValue
        }
      }
    }

    if (!md.isVirtual && !value['$amendment']) {
      if (md.entityName) {
        yield {entity: md.entityName, execParams: obj}
      } else {
        yield obj
      }
    }

    if (md.childCollections || md.defaultChildAttribute) {
      const childCollectionEntries = md.childCollections
        ? Object.entries(md.childCollections)
          .map(([childAttr, child]) => ([
            child,
            typeof child.getValue === 'function'
              ? child.getValue(value[childAttr], ctx)
              : value[childAttr]
          ]))
          .filter(([, value]) => value !== undefined)
        : [[md.defaultChildAttribute, value]]
      for (const [child, childValue] of childCollectionEntries) {
        let childCtx
        if (typeof child.createContext === 'function') {
          childCtx = child.createContext(obj, value, ctx)
        } else if (child.context) {
          const propValues = Array.isArray(child.context)
            ? child.context.reduce(
              (ctx, attr) => {
                ctx[attr] = obj[attr]
                return ctx
              },
              {}
            )
            : Object.entries(child.context).reduce(
              (ctx, [key, value]) => {
                ctx[key] = obj[value]
                return ctx
              },
              {}
            )
          childCtx = Object.assign(Object.create(ctx), propValues)
        } else {
          childCtx = ctx
        }

        if (typeof child.iterate === 'function') {
          for (const childVal of child.iterate(childValue, childCtx)) {
            yield childVal
          }
        } else if (child.metadata) {
          for (const childVal of transform(iterateList(childValue), child.metadata, childCtx)) {
            yield childVal
          }
        } else {
          throw new Error('In order to iterate children objects, need to define either "iterate" function, of "metadata" object')
        }
      }
    }
  }
}

/**
 * Iterate over item, map to iterables and iterate over result.
 * @param {IterableIterator<*>} source
 * @param {Function} map
 * @return {IterableIterator<*>}
 */
function* flatMap(source, map) {
  for (const item of source) {
    for (const i of map(item)) {
      yield i
    }
  }
}

/**
 * @param {Array<string>|string} stringOrArray
 * @return {Array<string>}
 */
function stringToArray(stringOrArray) {
  if (!stringOrArray) {
    return []
  }

  if (Array.isArray(stringOrArray)) {
    return stringOrArray
  }

  return stringOrArray.split(',').map(s => s.trim()).filter(s => !!s)
}

function* iterateChildren(val) {
  for (const child of stringToArray(val)) {
    yield [child]
  }
}

/**
 * Automatically build a name out of code value.
 * @param {string} code
 * @return {string}
 */
function codeToName(code) {
  return (/** @type {string} */ snakeCase(code))
    .split('_')
    .map(p => capitalize(p))
    .join(' ')
}

/**
 * @param {object} instance
 * @param {MigrationContext} ctx
 */
function addTranslations(instance, ctx) {
  const {langConfig, resources} = ctx
  const {defaultLang} = langConfig

  const repository = ctx.container.getRepository(instance.entity)
  if (!repository.multiLangAttributes || !repository.multiLangAttributes.length) {
    return
  }

  function normalizeTranslatedValue(value) {
    return typeof value === 'string'
      ? {[defaultLang]: value}
      : value || {}
  }

  const assignedDefaultValues = instance.execParams[ASSIGNED_DEFAULT_VALUES] || {}
  delete instance.execParams[ASSIGNED_DEFAULT_VALUES]

  for (const attrName of repository.multiLangAttributes) {
    const normalizedValue = normalizeTranslatedValue(instance.execParams[attrName])
    delete instance.execParams[attrName]

    const value = assignedDefaultValues[attrName] ? {} : normalizedValue
    const assignedDefaultValue = assignedDefaultValues[attrName] ? normalizedValue : {}

    const resourceKey = typeof normalizedValue.$i18n === 'string'
      ? normalizedValue.$i18n
      : [
        instance.entity,
        ...repository.keyAttributes.map(a => instance.execParams[a]),
        attrName
      ].join('.')
    delete normalizedValue.$i18n

    for (const l of ctx.langConfig.supportLang) {
      const translation = value[l] ||
        resources && resources.get(l, resourceKey) ||
        value[defaultLang] ||
        resources && resources.get(defaultLang, resourceKey) ||
        assignedDefaultValue[defaultLang] ||
        value['en'] // fallback to `en` in case localization not found

      if (translation !== undefined) {
        instance.execParams[attrName + '_' + l + '^'] = translation
      }
    }
  }
}

/**
 * Returns entity name with `_adm` of `_acl` suffix that stores access info for `baseEntityName` entity
 * @param {UBDomain} domainInfo
 * @param {string} baseEntityName
 * @returns {string}
 */
function getAdmEntityName(domainInfo, baseEntityName) {
  const admEntityName = `${baseEntityName}_adm`
  const aclRlsEntityName = `${baseEntityName}_acl`
  const existsAclEntity = Boolean(domainInfo && domainInfo.entities[aclRlsEntityName])

  return existsAclEntity ? aclRlsEntityName : admEntityName
}
