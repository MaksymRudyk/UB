const test = require('tape')
const utility = require('../lib/metadata/utility')
const {EntityRepository} = require('../lib/metadata/entity-repository')
const {EntityFormat} = require('../lib/metadata/entity-format')
const {LocaleResources} = require('../lib/locale-resources')
const {Container} = require('../lib/metadata')

const resources = new LocaleResources()

/** @type {MigrationContext} */
const ctx = {
  conn: null,
  langConfig: {defaultLang: 'en', supportLang: ['en', 'uk']},
  options: {silent: true},
  container: new Container({silent: true}),
  resources
}

ctx.container.registerRepository(
  new EntityRepository(
    'tst_entity',
    ['code'],
    undefined,
    ['name']
  )
)

ctx.container.registerRepository(
  new EntityRepository(
    'tst_master',
    ['code']
  )
)

ctx.container.registerRepository(
  new EntityRepository(
    'tst_detail',
    ['code']
  )
)

const tstEntityMd = new EntityFormat()
  .key('code')
  .caption('name')
  .wrapAsEntity('tst_entity')


resources.addResources('en', {
  'tst_entity': {
    code1: {
      name: 'Name1 from res en'
    }
  }
})

resources.addResources('uk', {
  'tst_entity': {
    code10: {
      name: 'Name10 from res uk'
    }
  }
})

function* iterateArray(arr) {
  for (const item of arr) {
    yield item
  }
}

test('Iterate lists', t => {
  function iterateToArray(data) {
    return Array.from(utility.iterateList(data))
  }

  t.deepEqual(
    iterateToArray('single'),
    [['single', undefined]],
    'Convert a single string to an array with a string as a key and value is undefined'
  )

  t.deepEqual(
    iterateToArray(['one', 'two']),
    [['one', undefined], ['two', undefined]],
    'Convert an array of strings to an array of entries, each with string as a key and value is undefined'
  )

  t.deepEqual(
    iterateToArray({foo: 'bar', baz: 'bro'}),
    [['foo', 'bar'], ['baz', 'bro']],
    'Convert an object to an array of key-value entries'
  )

  t.deepEqual(
    iterateToArray([
      {foo: 'bar', baz: 'bro'},
      {alice: 'bob', beep: 'boom'}
    ]),
    [
      ['foo', 'bar'],
      ['baz', 'bro'],
      ['alice', 'bob'],
      ['beep', 'boom']
    ],
    'Convert an array of object to a flat array of key-value entries from all of the objects'
  )

  t.deepEqual(
    iterateToArray([
      'one',
      {foo: 'bar', baz: 'bro'},
      'two',
      {alice: 'bob', beep: 'boom'}
    ]),
    [
      ['one', undefined],
      ['foo', 'bar'],
      ['baz', 'bro'],
      ['two', undefined],
      ['alice', 'bob'],
      ['beep', 'boom']
    ],
    'Convert a mixed array of objects and strings to key-value entries'
  )

  t.end()
})

test('Process list', t => {
  function processToArray(data, func, ctx) {
    return Array.from(utility.processList(iterateArray(data), func, ctx))
  }

  function testTransform(key, value, context) {
    return {
      code: key,
      name: value,
      myFoo: 'my-' + context.foo
    }
  }

  t.deepEquals(
    processToArray(
      [
        ['hello', 'world']
      ],
      testTransform,
      {foo: 'bar'}
    ),
    [
      {myFoo: 'my-bar', code: 'hello', name: 'world'}
    ],
    'Use root context and get correct key and value'
  )

  t.deepEquals(
    processToArray(
      [
        ['$context', {foo: 'bar2'}],
        ['hello', 'world'],
        ['$context', {foo: 'bar3'}],
        ['goodbye', 'world'],
      ],
      testTransform,
      {rootContext: {foo: 'bar'}}
    ),
    [
      {myFoo: 'my-bar2', code: 'hello', name: 'world'},
      {myFoo: 'my-bar3', code: 'goodbye', name: 'world'}
    ],
    'Override context as we go'
  )

  t.end()
})

test('Transform object', t => {
  function transformAndTranslate(md, data, context = ctx) {
    const source = iterateArray([data])
    const result = utility.transformAndTranslate(source, md, context)
    const r = Array.from(result)

    if (r.length !== 1) {
      t.fail('Expected one item, but got ' + JSON.stringify(r))
    }
    return r[0]
  }

  function transform(md, data, context) {
    const r = transformMany(md, data, context)
    if (r.length !== 1) {
      t.fail('Expected one item, but got ' + JSON.stringify(r))
    }
    return r[0]
  }

  function transformMany(md, data, context) {
    return transformManyToMany(md, [data], context)
  }

  function transformManyToMany(md, data, context) {
    const source = iterateArray(data)
    const result = utility.transform(source, md, context || ctx)
    return Array.from(result)
  }

  t.deepEquals(
    transform(
      new EntityFormat(),
      ['foo', 'bar']),
    {},
    'No action'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .key('code2'),
      ['foo', 'bar']
    ),
    {code2: 'foo'},
    'Set key to "code2" attribute'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .nonObjectValueAsAttribute('name'),
      ['foo', 'bar']
    ),
    {name: 'bar'},
    'Set non-object value to default "name" attribute'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .nonObjectValueAsAttribute('name'),
      ['foo', {name: 'bar'}]
    ),
    {name: 'bar'},
    'Set default "name" attribute, when it is an attribute in object value'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .copy('bar', 'not-here'),
      ['foo', {bar: 'baz', butNot: 'this-value'}]
    ),
    {bar: 'baz'},
    'Copy some properties from value'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .defaultValue('alice', 'not Bob')
        .defaultValue('bar', 'baz'),
      ['foo', 'miss this value']
    ),
    {alice: 'not Bob', bar: 'baz'},
    'Apply default values'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .copy('alice')
        .defaultValue('alice', 'not Bob')
        .defaultValue('bar', 'baz'),
      ['foo', {alice: 'Bob!'}]
    ),
    {alice: 'Bob!', bar: 'baz'},
    'Default values must not override explicit values'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .defaultValue('name', 'Alice'),
      ['foo', undefined]
    ),
    {name: 'Alice'},
    'Must use default value for default attribute'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .key('code')
        .defaultValue('name', obj => obj.code.toUpperCase()),
      ['foo', undefined]
    ),
    {code: 'foo', name: 'FOO'},
    'Must use default value, when defined as a function'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .key('code')
        .nonObjectValueAsAttribute('name')
        .defaultValue('name', obj => obj.code.toUpperCase()),
      ['foo', undefined]
    ),
    {code: 'foo', name: 'FOO'},
    'Must use default value for default attribute, when defined as a function'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .defaultValue('name', 'Alice')
        .nonObjectValueAsAttribute('name'),
      ['foo', 'bar']
    ),
    {name: 'bar'},
    'Default value must not override explicit value, when passed as string'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .nonObjectValueAsAttribute('name')
        .transform('name', val => val + '-transformed'),
      ['foo', 'bar']
    ),
    {name: 'bar-transformed'},
    'Must transform a value'
  )

  t.deepEquals(
    transformManyToMany(
      new EntityFormat()
        .nonObjectValueAsAttribute('name')
        .transform('name', (val, ctx) => {
          if (!ctx.hasOwnProperty('num')) {
            ctx.num = 0
          }
          ctx.num += 10
          return val + '-transformed-' + ctx.num
        }),
      [
        ['foo', 'bar'],
        ['foo2', 'bar2']
      ]
    ),
    [{name: 'bar-transformed-10'}, {name: 'bar2-transformed-20'}],
    'Must pass context, when transform a value'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .defaultValue('name', 'Alice')
        .nonObjectValueAsAttribute('name'),
      ['foo', 'bar']
    ),
    {name: 'bar'},
    'Default values must not override explicit value, when passed as object'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .key('code')
        .defaultValue('code', 'any-key'),
      ['foo', 'bar']
    ),
    {code: 'foo'},
    'Default value for key attribute - has no sense, but shall work and must not override explicit value'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .key('code')
        .fromContext('parentCode'),
      ['foo', 'bar'],
      {parentCode: 'code5'}
    ),
    {code: 'foo', parentCode: 'code5'},
    'Shall copy attribute value from context'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .key('code')
        .fromContext({parentCode: 'code'}),
      ['foo', 'bar'],
      {code: 'code5'}
    ),
    {code: 'foo', parentCode: 'code5'},
    'Shall copy attribute value from context, using map'
  )

  // TODO: allow override context locally?

  t.deepEquals(
    transformMany(
      new EntityFormat()
        .key('code')
        .child('items', {
          context: {parentCode: 'code'},
          metadata: new EntityFormat()
            .key('code')
            .nonObjectValueAsAttribute('name')
            .fromContext('parentCode')
        }),
      ['foo', {items: {bar: 'baz'}}]
    ),
    [
      {code: 'foo'},
      {parentCode: 'foo', code: 'bar', name: 'baz'}
    ],
    'Shall create child items and use parent context'
  )

  t.deepEquals(
    transformMany(
      new EntityFormat()
        .key('code')
        .child('items', {
          context: {parentCode: 'code'},
          getValue(val) {
            return Object.assign({}, val, {newProp: 'newValue'})
          },
          metadata: new EntityFormat()
            .key('code')
            .nonObjectValueAsAttribute('name')
            .fromContext('parentCode')
        }),
      ['foo', {items: {bar: 'baz'}}]
    ),
    [
      {code: 'foo'},
      {parentCode: 'foo', code: 'bar', name: 'baz'},
      {parentCode: 'foo', code: 'newProp', name: 'newValue'}
    ],
    'Ability to override getValue for child collection'
  )

  t.deepEquals(
    transformMany(
      new EntityFormat()
        .key('code')
        .child('items', {
          createContext(obj, definition, ctx) {
            return Object.assign(Object.create(ctx), {parentCode: obj.code})
          },
          iterate(val, ctx) {
            return utility.transform(
              utility.iterateList(val),
              new EntityFormat()
                .key('code')
                .nonObjectValueAsAttribute('name')
                .fromContext('parentCode'),
              ctx
            )
          }
        }),
      ['foo', {items: {bar: 'baz'}}],
    ),
    [
      {code: 'foo'},
      {parentCode: 'foo', code: 'bar', name: 'baz'}
    ],
    'Shall create child items and use parent context (use functions)'
  )

  t.deepEquals(
    transformMany(
      new EntityFormat()
        .key('code')
        .child('items', {
          context: ['code'],
          metadata: new EntityFormat()
            .key('code')
            .nonObjectValueAsAttribute('name')
            .fromContext({parentCode: 'code'})
        }),
      ['foo', {items: {bar: 'baz'}}],
    ),
    [
      {code: 'foo'},
      {parentCode: 'foo', code: 'bar', name: 'baz'}
    ],
    'Shall create child items and use parent context, when parent context attributes defined as array'
  )

  t.deepEquals(
    transformMany(
      new EntityFormat()
        .key('code')
        .defaultChild({
          context: {parentCode: 'code'},
          metadata: new EntityFormat()
            .key('code')
            .fromContext('parentCode')
            .nonObjectValueAsAttribute('name')
        }),
      [
        'foo',
        {bar: 'baz'}
      ],
    ),
    [
      {code: 'foo'},
      {parentCode: 'foo', code: 'bar', name: 'baz'}
    ],
    'Shall create child items for default child item'
  )

  t.deepEquals(
    transformMany(
      new EntityFormat()
        .key('code')
        .virtual()
        .defaultChild({
          context: {parentCode: 'code'},
          metadata: new EntityFormat()
            .key('code')
            .nonObjectValueAsAttribute('name')
            .fromContext('parentCode')
        }),
      ['foo', {bar: 'baz'}],
    ),
    [
      {parentCode: 'foo', code: 'bar', name: 'baz'}
    ],
    'Shall omit parent item, if it is virtual'
  )

  t.deepEquals(
    transform(
      tstEntityMd,
      ['foo', undefined],
    ),
    {entity: 'tst_entity', execParams: {code: 'foo', name: 'Foo'}},
    'Shall wrap into entity'
  )

  t.deepEquals(
    transformMany(
      new EntityFormat()
        .key('code')
        .wrapAsEntity('tst_master')
        .defaultChild({
          context: {parentCode: 'code'},
          metadata: new EntityFormat()
            .key('code')
            .fromContext('parentCode')
            .nonObjectValueAsAttribute('name')
            .wrapAsEntity('tst_detail')
        }),
      [
        'foo',
        {bar: 'baz', boom: 'box'}
      ],
    ),
    [
      {entity: 'tst_master', execParams: {code: 'foo'}},
      {entity: 'tst_detail', execParams: {parentCode: 'foo', code: 'bar', name: 'baz'}},
      {entity: 'tst_detail', execParams: {parentCode: 'foo', code: 'boom', name: 'box'}}
    ],
    'Shall wrap parent and child each into own entity'
  )

  t.deepEquals(
    transformAndTranslate(
      new EntityFormat()
        .key('code')
        .copy('name')
        .wrapAsEntity('tst_entity'),
      ['foo', {name: 'Hello'}]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'foo', 'name_en^': 'Hello', 'name_uk^': 'Hello'}
    },
    'Shall translate attribute'
  )

  t.deepEquals(
    transformAndTranslate(
      new EntityFormat()
        .key('code')
        .copy('name')
        .wrapAsEntity('tst_entity'),
      ['foo', {name: {en: 'Hello'}}]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'foo', 'name_en^': 'Hello', 'name_uk^': 'Hello'}
    },
    'Shall translate attribute, when defined as value of default language'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['foo', 'Hello']
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'foo', 'name_en^': 'Hello', 'name_uk^': 'Hello'}
    },
    'Shall translate attribute, when defined as caption'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['foo', undefined]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'foo', 'name_en^': 'Foo', 'name_uk^': 'Foo'}
    },
    'Shall translate attribute, when defined as autogenerated caption'
  )

  t.deepEquals(
    transform(
      new EntityFormat()
        .key('code'),
      ['foo', 'Hello']
    ),
    {code: 'foo'},
    'Shall not fail if no input for translatable attribute'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['foo', {name: {en: 'Hello', uk: 'Привіт', ru: 'Привет'}}]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'foo', 'name_en^': 'Hello', 'name_uk^': 'Привіт'}
    },
    'Shall translate attribute, when defined as caption and there is explicit value'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['foo', {en: 'Hello', uk: 'Привіт', ru: 'Привет'}]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'foo', 'name_en^': 'Hello', 'name_uk^': 'Привіт'}
    },
    'Shall translate attribute, when defined as caption and default value with translations'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['foo', {en: 'Hello', uk: 'Привіт', ru: 'Привет'}]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'foo', 'name_en^': 'Hello', 'name_uk^': 'Привіт'}
    },
    'Shall get translation from resources'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['code1', {uk: 'Привіт'}]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'code1', 'name_en^': 'Name1 from res en', 'name_uk^': 'Привіт'}
    },
    'Shall get translation from resources'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['code10', 'Name10']
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'code10', 'name_en^': 'Name10', 'name_uk^': 'Name10 from res uk'}
    },
    'Shall get translation from resources'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['code10', {name: 'Name1'}]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'code10', 'name_en^': 'Name1', 'name_uk^': 'Name10 from res uk'}
    },
    'Shall get translation from resources'
  )

  t.deepEquals(
    transformAndTranslate(
      tstEntityMd,
      ['code10', {}]
    ),
    {
      entity: 'tst_entity',
      execParams: {code: 'code10', 'name_en^': 'Code 10', 'name_uk^': 'Name10 from res uk'}
    },
    'Shall get translation from resources'
  )

  t.end()
})
