# Summary

This is a CLI tool, and a library for managing UB data, such as system roles, desktops, navigation shortcuts and enums.

Even UnityBase has the `ubcli initialize` command, it only can create data one time, at the moment of database creation.
Changes in data cannot be handled by `ubcli initialize`, and that is why `ub-migrate` was created.

There is a bunch of approaches in different existing projects on UnityBase: use CSV files, hand-written data-creation and
data-migration scripts, json files.
The problem with those existing practices:
* They are not consistent - different practices for different projects / groups of projects
* No documentation available for any of them
* Hard to reuse - you have to copy code from one project to another and tailor it to your needs.

This package supposed to solve all these problems.

I put the following design goals for this package:
* Human as a first-class user of this tool.  This means no data duplication, minimal format overhead, "smart" format
  intuitively understandable for anyone who would read data definition.
* The same code for initial data creation and further data maintenance.
* Ability to use as a CLI tool, which means, it must parse `ubConfig.json`, find all models, execute
  initialization/migration for each.

## Features

* Use YAML for defining data - one of the most human-friendly formats 
  * Those, who tried to specify `ubm_navshortcut.cmdCode` value as JSON would understand :)
  * It would be great to put a comment line or a few into data definition file, right?
* Single utility for initial data creation and changing data from build to build
* If a data record exists in database, it will be updated, only if any property changed, otherwise record
  will be created
* If `name` or `caption` attribute is not specified, automatically generate it by code, where appropriate.
* Automatically maintain `sortOrder` / `displayOrder` using order of items in the data definition files.
* For hierarchical data, like navigation shortcuts, use hierarchical definition, no need to specify `parentID`, ever
* Natural structuring data: group enumeration items, put navigation shortcuts under desktop, define ELS rules
  straight when you define role, etc.
* The tool just tries to be smart: it "knows" that navigation shortcuts containing other items inside are folders,
  and those without items are not, it assumes that access permissions for navigation shortcut folder should be
  inherited to shortcuts beneath it, if not specified otherwise, etc.

# Utility usage

First, the utility should be installed as a developer dependency into your project:
```cmd
npm install -D @unitybase/ub-migrate
```

The utility is embedded into `ubcli migrate` and run automatically every time `ubcli migrate` runs.
Separately, the utility might be called from command line:
```cmd
npx ub-migrate
```

It will look the current folder for `ubConfig.json` file, browse models for data definition files and
migrate data as defined in the files.

To specify custom configuration file, use the following syntax:
```cmd
npx ub-migrate -cfg ubConfig-dev.json
```


# Data definition files

## Enums

For enums, there is a lot of overhead for a developer, when describe enums in the CSV format:
* You have to manually manage `sortOrder`, while it is handy to automatically generate it, basing on order of items in
  the data definition file.  A multiplier of 10 still may be applied, so that automatically generated numbers would be:
  10, 20, 30, ...   
* There is no place for commentary in the CSV (or JSON) file, while it would be handy to put a line or two per enum
  group.
* Enumeration group name is replicated
* Translations usually go as separate CSV files, where as a developer you need to put all enum items again. 

The following is a format supported by the library:
```yaml
# Specify data type
$context:
  type: enums

# Used for `status` attribute for all document entities
DOC_STATUS:
- draft: {ru: Черновик, uk: Чернетка}
- on_review: {ru: На ревизии,uk: На ревізії}
- on_approval: {ru: На утрведжении, uk: На затверджені}
- returned: {en: Return for Rework, ru: Возвращен на доработку, uk: Повернений на доопрацювання}
- approved: {ru: Утвержден, uk: Затверджений}
- completed: {ru: Завершен, uk: Завершений}
- cancelled: {ru: Отменен, uk: Відмінений}
```
Use `$context` object with `type` property `enums` so library knows what metadata use.

Each enumeration group is a separate top-level key, and value is an array of enumeration group items - you will never
need to type the same enumeration group name twice with such approach.

Enumeration group item is an object with just one key - the code.
The default language name is not required, because it may be automacially built just by capitalizing the code and
replacing separator symbols like underscore or hyphen with space:
- `draft` -> `Draft`
- `on_review` -> `On review`
- ...
It does not mean though that custom name may not be specified, but it covers majority (at least 80%) or real-life
enumeration items, saving developers from making mistakes on routine actions.

In the most simple cases, it is possible to skip translations and just define enums as:
```yaml
DOC_STATUS: [draft, on_review, completed]
```

This is the shortest possible way to define the enums, which would still work. 

And from other hand, when it is needed to define more properties, not just `code` and `name`, enum definition still
allows it via more complex structure:
```yaml
# Used for `status` attribute for all document entities
UOM:
- kg:
    shortName: {en: kg, ru: кг, uk: кг}
    name: {en: Kilogramms, ru: Килограммы, uk: Килограми}
``` 

Another case could be when you want to customize how `sortOrder` value is built.  For example, if you want to set custom
value, it is possible:
```yaml
# Used for `status` attribute for all document entities
DOC_STATUS:
- draft: {ru: Черновик, uk: Чернетка}
- on_review: {ru: На ревизии,uk: На ревізії}
- completed:
    sortOrder: 100  # This item's order is 100, every next continue from 100
    translations: {ru: Завершен, uk: Завершений}
- cancelled: {ru: Отменен, uk: Відмінений}
```
And all items after the custom values after the item with a custom value will continue numbering starting from it,
so that `cancelled` would have `sortOrder` equal `110`.

This feature is handy to create `gaps` between items.
The very similar approach would be useful for navigation shortcuts.

## System Roles

Defining system roles in UnityBase in many cases goes along with ELS rules for those roles.
If go with CSV files, the following are actions developers are required to do:
* Specify ELS rule code.
* Specify ELS rule description.
* Specify ELS rule role.
Code and description in many cases are typical, and when define multiple rules for the same role, you just
copy and paste it on multiple lines.

The migration engine allows you to define system roles and ELS rules for them in the following way:
```yaml
# Specify data type
$context:
  type: roles

buyer:
  els:
    read: pln, inv, bdg, org, cdn
    write: pln

supply_manager:
  description: Supply Chain Manager
  els:
    read: [pln, inv, bdg, org, cdn, ubs_settings]
    write: [pln, inv, bdg]
    custom: [org_employee.selectCustom, cdn_bank.checkCode]
```
Use `$context` object with `type` property `roles` so library knows what metadata use.

For access rules, the module tolerant to array or comma-separated strings.
It will automatically expand model name to entity mask for the model, for example `org` will be expanded to `org_*`.
It is possible though to specify individual entities or custom entity masks.

Here is list of predefined access types:

| Access types       | Methods available                      |
| ------------       | -----------------                      |
| read               | select                                 |
| crud               | select, addnew, insert, update, delete |
| write              | addnew, insert, update, delete         |
| read_update        | select, update                         |
| read_insert_update | select, addnew, insert, update         |


Read access methodMask is `select*` and write access method mast is `[uiad]*`, so that `insert`, `update`,
`delete` and `addnew` methods would be available.

By default, role name is built from role code just like enums do: capitalize code, replace separator symbol with space.
Just like for enums, it is possible to define a custom name.

`Deny` rule can be specified using `custom` type. Also `custom` type allows adding entity mask, method mask and rule
 description as comma separated string.
 
 Example below adds `deny`(D) ELS rule (note a `!` in the beginning) 
with code `ORG_UNIT_DENY` for  entity mask `org_unit` and method mask `[iuda]*` for role `Everyone`.
Description of added rule is `Deny direct modification of UNITY org_unit` (comma inside a description should not be used).

```
Everyone:
  $amendment: true
  els:
    custom:
    - ORG_UNIT_DENY: "!org_unit,[iuda]*,Deny direct modification of UNITY org_unit"
```
 
`$amendment` directive here prevents modifying an `Everyone` role and instruct ub-migrate to add `els` rules only
(see blow about $amendment) 

ELS rules are specified in place.
In many cases, rules specify read or write access for entire models.  This is possible to do with just one line for
multiple.

## Desktops and Navigation shortcuts

As for desktops and navigation shortcuts, goals are to provide help with the following routines:
- Define desktops and shortcuts in the same place, do not repeat desktop code more than once per file
- Have translations in place
- Have permissions in place (*_adm tables content)
- Generate default caption
- Generate `displayOrder` automatically
- Manage shortcut groups as a collection of nested items
- Be able to specify custom JSON or JavaScript inline

For example:

```yaml
# Specify data type
$context:
  type: navigation

bpm_desktop:
  caption: {en: Business Processes, ru: Рабочие процессы}
  description: {en: List of user tasks, started process and dashboard, ru: Список задач пользователя, запущенных процессов и дашбоард}
  iconCls: fas fa-desktop
  access: bpmUser, bpmAdmin
  items:
  - bpm_tasks:
      caption: {en: Tasks, ru: Задачи}
      items:
      - bpm_my_tasks:
          caption: {en: My Tasks, ru: Мои задачи}
          cmd: >
            {
              "cmdType": "showList",
              "cmdData": {
                "params": [{
                  "entity": "bpm_Task",
                  "method": "select",
                  "fieldList": ["subject", "description", "status"]
                }]
              }
            }
```

Use `$context` object with `type` property `navigation` so library knows what metadata use.

NOTE: rights to shortcuts are inherited from desktop down to folders and/or shortcuts.
Be sure to override access rights in folder or shortcut level.

In many cases, for commands, which just show list of an entity, it would be easier to just enumerate those
columns, which would give much cleaner definition:
```yaml
bpm_desktop:
  name: {en: Business Processes, ru: Рабочие процессы}
  access: bpmUser, bpmAdmin
  items:
  - bpm_tasks:
      name: {en: My Tasks, ru: Мои задачи}
      access: bpmUser, bpmAdmin
      showList:
        entity: bpm_Task
        fieldList: [subject, description, status]
```

Note that the definition about contains navigation shortcut with code `bpm_tasks` and it shows entities `bpm_Task`.
If we make shortcut code the same as entity name, we could omit the entity name.  And  we may omit the access,
because it is the same as access for the desktop.
So optimized definition would look like:

```yaml
bpm_desktop:
  caption: {en: Business Processes, ru: Рабочие процессы}
  access: bpmUser, bpmAdmin
  items:
  - bpm_Task:
      caption: {en: My Tasks, ru: Мои задачи}
      showList:
        fieldList: [subject, description, status]
```

In case you need shortcut to open some form instead of row list use this example:

```yaml
  items:
  - buk_questionnaire:
      caption: Анкета
      showForm: buk_questionnaire
```

## Users

For users key attribute is name (login). Other than simple fields (like `firstName`, `lastName`), you can specify roles and groups.
Use `$context` object with `type` property `users` so library knows what metadata use.

```yaml
$context:
  type: users

user1: # login
  firstName: testFirstName
  lastName: testLastName
  description: User the first
  roles: role1, role2
  groups: group1, group2
```

To set password to user, specify it in the `password` in plain text - ub-migrate will calculate a password hash
automatically:

 - to force user to change password on first logon set `lastPasswordChangeDate` for far to the past
 - to force password to newer expire set `lastPasswordChangeDate` for far to the future (2100-01-01 for example)


```yaml
user1: # login
  firstName: test
  lastName: test
  # password will be hashed automatically
  password: myPassword
  lastPasswordChangeDate: 2000-01-01
```

## Custom entity

It is possible to extend the predefined metadata to allow you to insert data from yaml files into your custom entity.
Use method `extend.registerEntity`:
```js
const { extend } = require('@unitybase/ub-migrate')

extend.registerEntity(
  'productEntity',
  ['code'],
  ['name', 'category', 'subCategory']
)
```

registerEntity takes next arguments:
  - entityName  
  Name of entity (name your meta file).
  - keyAttributes  
  Array of unique attributes (usually one) witch identify your entity. Use value of this attribute as **key**, when describe your data in yaml.
  - regularAttributes  
  Array of other simple (string, enum, etc) attributes.
  - translatableAttributes  
  Array of attributes witch may be described in multilingual format. (name: {en: My Tasks, ru: Мои задачи})
  - lookupAttributes  
  Array of attributes witch in yaml set as value, but in base must be stores as ID (happens for 'Entity' type fields ).
  ```js
  [{
      repository: 'uba_user', attribute: 'user', targetAttribute: 'userID'
  }]
  ``` 
  - nonUpdatableAttributes  
  Array of attributes witch will be set only on insert, but will keep value on update.

In yaml file set $context.type as name entity:
```yaml
$context:
  type: productEntity
  
code1:
  name: some name
  category: some category
  subCategory: some subCategory
```

# Translations

There many ways to deal with translatable attributes:
- Do not specify translations.
  Treat multilingual attribute as a regular attribute.  In such a case, the provided value will be copied in all
  supported languages.  Sometimes, when there is only one supported language is planned, or for testing,
  or on state of prototyping, that is enough.
- Specify translations in yaml file, inline.

  ```yaml
  bpm_desktop:
    caption: {en: Business Processes, ru: Рабочие процессы}
  ```

  This is a handy way to maintain translations by developers.  In many cases, initial 2-3 languages are defined on stage
  of development, and YAML is a far easier way of defining data than JSON, because of better readability and
  less syntax.

- Provide translations in separate JSON files.
  This is the most convenient way to deal with translation services, because JSON format is much easy to automate and
  import / export translations from/to excel (which is not scope of this tool yet).

  The JSON files must be located in models `_data/locale` subdirectory and file names must follow the same convention as
  in `public/locale` folder: `lang-<xx>.json`, for example: `lang-en.json`:

  ```json5
  {
    "ubm_enum": {
      "BPM_PROC_DEF_STATUS": {
        "draft": {"name": "Draft"},
        "deployed": {"name": "Deployed"},
        "old": {"name": "Old Version"}
      }
    },
    // localization for *navigation.yaml - ubm_desktop / ubm_navshortcut should be used as entity name
    // example below localize navigation for *navigation.yaml:
    // $context:
    // type: navigation
    // adm_desktop:
    //   caption: Administrator 
    "ubm_desktop": {
      "adm_desktop": {
        "caption": "Администратор"
      }
    }
  }
  ```

  The translations values in YAML and JSON files are merged, so if initial language set may come in YAML and extra
  languages in JSON.

  Structure of JSON:
  - entity name / code / attribute
    OR, for entities, like ubm_enum, which have composite code (eGroup + code)
  - entity name / code1 / code2 / attribute

Sometimes, data translations already exists in some other place, for example, navigation shortcut caption is often
an exact match of entity name.
In order to avoid resource duplication, if is possible to point to an existing locale resource:

```yaml
dsk_dfx_admin:
  caption: {$i18n: dfx_DocType}
```

Just specify `{$i18n: literal_key}` instead of actual value and ub-migrate will get the translations and use it.

# Advanced features

## `$amendment` directive

Sometimes, one model declares an object, like desktop, and some other models wants to add child items, like
navigation shortcuts.

Example:

```
# Submenu in "Administrator" desktop
adm_desktop:
  $amendment: true
  items:
  - adm_bpm:
      $amendment: true
      items:
      - bpm-camunda_sync:
          access: bpmAdmin
          caption:
            en: Camunda Synchronization
            ru: Синхронизация процессов и задач
            uk: Синхронізація процесів та завдань
          iconCls: fa fa-exchange
          displayOrder: 200
          showForm: camunda_Database-sync
```
