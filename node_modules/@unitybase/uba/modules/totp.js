/**
 * TOTP two factor auth verification. See [Time-based One-time Password algorithm](https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm)
 *
 * @module totp
 * @memberOf module:@unitybase/uba
 * @author UnityBase team
 */
const RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
const RFC4648_HEX = '0123456789ABCDEFGHIJKLMNOPQRSTUV'
const CROCKFORD = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'
/**
 * Key lifetime in seconds
 * @type {number}
 */
const PERIOD = 30
/**
 * verifyTotp use all this time shifts to allow small (up to 90 sec) time synchronization shifts
 * between server and Authenticator device
 */
const VERIFICATION_SHIFTS = [0, -30, +30, -60, +60, -90, +90]

/* global nhmac_sha1 nsha256 createGuid */

module.exports = {
  verifyTotp,
  getTotpQRCodeData,
  generateTotpSecret,
  getTotp
}

/**
 * Generate TOTP by given secret
 * @param {string} secret User secret previously generated by generateTotpSecret
 * @param {number} [shift=0] Time shift in seconds. Can be used to generate +-30(90) second TOTP value to compare
 *   with result from user - this allows small time un-sync (or slow network) between user device and server
 * @return {string} TOTP value (6 digits code)
 */
function getTotp (secret, shift) {
  shift = shift || 0
  let hkey = base32ToHex(secret)
  let secondSinceEpoch = Math.round(Date.now() / 1000.0)
  let time = dec2hex(Math.floor((secondSinceEpoch + shift) / PERIOD)).padStart(16, '0')
  let hmac = nhmac_sha1(Buffer.from(hkey, 'hex'), Buffer.from(time, 'hex'))
  let offset = parseInt(hmac.substring(hmac.length - 1), 16)
  let otp = (parseInt(hmac.substring(offset * 2, offset * 2 + 8), 16) & 0x7fffffff) + ''
  otp = otp.substring(otp.length - 6, otp.length)
  return otp
}

/**
 * Verify TOTP by given secret.
 * @param {string} secret
 * @param {string} userPassedTotp
 * @return {boolean}
 */
function verifyTotp (secret, userPassedTotp) {
  for (let i = 0, L = VERIFICATION_SHIFTS.length; i < L; i++) {
    if (getTotp(secret, VERIFICATION_SHIFTS[i]) === userPassedTotp) return true
  }
  return false
}

/**
 * Create a QR code content for given secret
 * See [TOTP URI format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format)
 * @param {string} label Used to identify which account a key is associated with
 * @param {string} secret User secret previously generated by generateTotpSecret
 * @param {string} issuer Provider or service this account is associated with (our organization)
 * @return {string}
 */
function getTotpQRCodeData (label, secret, issuer) {
  return encodeURI('otpauth://totp/' + label + '?secret=' + secret + '&issuer=' + issuer)
  // return 'https://chart.googleapis.com/chart?chs=200x200&chld=M|0&cht=qr&chl=' + data + ''
}

/**
 * Create a random TOTP secret
 * @return {string}
 */
function generateTotpSecret () {
  let b = Buffer.from(nsha256(createGuid()).slice(0, 16))
  return base32Encode(b, 'RFC3548', { padding: false })
}

function dec2hex (s) {
  return (s < 15.5 ? '0' : '') + Math.round(s).toString(16)
}

function base32ToHex (base32) {
  let base32chars = RFC4648
  let bits = ''
  let hex = ''

  for (let i = 0; i < base32.length; i++) {
    let val = base32chars.indexOf(base32.charAt(i).toUpperCase())
    bits += val.toString(2).padStart(5, '0')
  }

  for (let i = 0; i + 4 <= bits.length; i += 4) {
    let chunk = bits.substr(i, 4)
    hex = hex + parseInt(chunk, 2).toString(16)
  }
  return hex
}

function base32Encode (buffer, variant, options) {
  options = options || {}
  let alphabet, defaultPadding

  switch (variant) {
    case 'RFC3548':
    case 'RFC4648':
      alphabet = RFC4648
      defaultPadding = true
      break
    case 'RFC4648-HEX':
      alphabet = RFC4648_HEX
      defaultPadding = true
      break
    case 'Crockford':
      alphabet = CROCKFORD
      defaultPadding = false
      break
    default:
      throw new Error('Unknown base32 variant: ' + variant)
  }

  let padding = (options.padding !== undefined ? options.padding : defaultPadding)
  let length = buffer.byteLength
  let view = new Uint8Array(buffer)

  let bits = 0
  let value = 0
  let output = ''

  for (let i = 0; i < length; i++) {
    value = (value << 8) | view[i]
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}
